<!doctype html><html lang=en-us class="m-auto ocean"><head><title>Riccardo Belli</title><meta name=theme-color content><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta name=description content="Riccardo Belli's personal page and portfolio."><meta name=author content="Riccardo Belli"><meta name=generator content="aafu theme by Darshan in Hugo 0.109.0"><meta name=keywords content="Riccardo Belli"><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.15.2/css/all.css integrity=sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu crossorigin=anonymous><link rel=stylesheet href=https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Didact+Gothic%7CRoboto:400%7CRoboto+Mono"><link rel=stylesheet href=/css/aafu.css><link rel=stylesheet href=/css/aafu_compiled.css><script>let html=document.querySelector("html"),theme=window.localStorage.getItem("theme");theme?theme==="dark"?html.classList.add("dark"):html.classList.remove("dark"):html.classList.contains("dark")?window.localStorage.setItem("theme","dark"):(html.classList.remove("dark"),window.localStorage.setItem("theme","light")),window.onload=()=>{let e=document.querySelector(".theme-toggle");window.localStorage.getItem("theme")==="dark"?(e.classList.remove("bi-moon-fill"),e.classList.add("bi-brightness-high")):(e.classList.add("bi-moon-fill"),e.classList.remove("bi-brightness-high"));let t=document.querySelector(".accordion.active");t&&(t.nextElementSibling.style.maxHeight=t.nextElementSibling.scrollHeight+"px")},window.onresize=()=>{let e=document.querySelector(".accordion.active");e&&(e.nextElementSibling.style.maxHeight=e.nextElementSibling.scrollHeight+"px")}</script></head><body class="h-screen px-2 pb-2 pt-0 m-auto max-w-4xl flex flex-col"><header class="nav flex flex-row row p-2 mb-6 w-full border-b border-gray-300 dark:border-gray-700 justify-between"><div><a class="mx-0 no-underline p-2 rounded hover:bg-gray-200 dark:hover:bg-gray-800" href=https://www.riccardobelli.it/>Home</a>
<a class="mx-0 no-underline p-2 rounded hover:bg-gray-200 dark:hover:bg-gray-800" href=/blog>Blog</a>
<a class="mx-0 no-underline p-2 rounded hover:bg-gray-200 dark:hover:bg-gray-800" href=/projects>Projects</a>
<a class="mx-0 no-underline p-2 rounded hover:bg-gray-200 dark:hover:bg-gray-800" href=/files/Riccardo_Belli_CV.pdf>My CV</a></div><i class="fas fa-sun theme-toggle text-blue-500 hover:text-blue-700 dark:text-yellow-300 dark:hover:text-yellow-500 cursor-pointer text-lg px-2 mr-0 sm:mr-0" onclick=lightDark(this)></i></header><script>const lightDark=e=>{let t=document.querySelector("html");t.classList.contains("dark")?(t.classList.remove("dark"),e.classList.add("fa-moon"),e.classList.remove("fa-sun"),window.localStorage.setItem("theme","light")):(t.classList.add("dark"),e.classList.add("fa-sun"),e.classList.remove("fa-moon"),window.localStorage.setItem("theme","dark"))}</script><main class=grow><div class="prose prose-stone dark:prose-invert max-w-none"><div class=mb-3><h1 class=top-h1 style=font-size:2.75em>MISRA-C friendly C99 static assert macro</h1><p class=mb-1>January 14, 2023</p><p>&mdash;</p></div><div class=content><h2 id=and-a-little-extra>&mldr;and a little extra!</h2><p><strong>⚠️</strong> If you already know what I&rsquo;m talking about and you just want the macro, you can directly jump to the <a href=#conclusions>conclusions.</a></p><p>Oftentimes, especially in embedded programming, there are some checks that are better run at compile time rather than at runtime. Let&rsquo;s say that you have a codebase (for example a library) that has some functionality that relies on the platform&rsquo;s <code>unsigned int</code> to be exactly 4 bytes, or a <code>long</code> to be exactly 8, or the <code>char</code> type to be signed, and so on. There <em>could</em> be many comments written in the code about these constraints, but in the end who&rsquo;s stopping you (or someone else) from using this code?</p><p>Consider this: let&rsquo;s say that you have a <code>struct</code> that needs to be <em>exactly</em> of a certain, specified size for some library/application:</p><ul><li><h5 id=example-1>Example 1:</h5></li></ul><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#c678dd>typedef</span> <span style=color:#c678dd>struct</span> <span style=color:#8a93a5;font-style:italic>// __attribute__((packed))
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span>{
</span></span><span style=display:flex><span>    <span style=color:#ef8383>short</span> <span style=color:#c1abea>a</span>;
</span></span><span style=display:flex><span>    <span style=color:#ef8383>char</span> <span style=color:#c1abea>b</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} <span style=color:#c1abea>PackedOrNot_t</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic> * Do we need the packed attribute?
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic> * If so, how do we enforce it?
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic> */</span>
</span></span></code></pre></div><p>In this case the <code>struct</code>&rsquo;s <code>sizeof</code> size can be either 3 or 4 bytes, depending on if we use a <code>packed</code> attribute or not. How can we make sure that such an error never slips? What if we have other people working with us at the same project, or if we need to hand over the project/library altogether?</p><p>Or another example: let&rsquo;s assume that we have a <code>struct</code> that is 1:1 representative of some specific, real-world data. Let&rsquo;s say that it needs to be sent via an interface that requires it to be a multiple of 8 bytes in size (e.g. via CAN). How can you be programmatically secure that adding elements to our <code>struct</code> results in it being exactly 8-bytes aligned? We might add some comments explaining how to pad the structure with extra reserved bytes but we&rsquo;re always a slip away from a potential source of nasty runtime bugs.</p><ul><li><h5 id=example-2>Example 2:</h5></li></ul><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#c678dd>typedef</span> <span style=color:#c678dd>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ef8383>char</span> <span style=color:#c1abea>someData</span>;
</span></span><span style=display:flex><span>    <span style=color:#ef8383>char</span> <span style=color:#c1abea>someMoreData</span>;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#8a93a5;font-style:italic>/* Assume this structure definition is very long,
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>     * possibly even with other structs inside of it.
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>     */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} <span style=color:#c1abea>EightBytesMultiple_t</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic> * ..are we sure that it&#39;s always going 8-bytes*n long?
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic> */</span>
</span></span></code></pre></div><p>One last example: before C99, integer division behavior was implementation dependent (rounding can go toward zero or toward negative infinity). From C99 onwards, integer division is well defined as it performs truncation towards zero. If some of your logic depends on this behavior being <em>well defined</em>, how do you enforce at compile time?</p><ul><li><h5 id=example-3>Example 3:</h5></li></ul><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>// Before C99 (for example in ANSI-C) the result could
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>// be either -2 or -3 depending on the implementation!
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span><span style=color:#ef8383>int</span> <span style=color:#c1abea>result</span> <span style=color:#c7bf54>=</span> <span style=color:#c7bf54>-</span><span style=color:#d19a66>10</span> <span style=color:#c7bf54>/</span> <span style=color:#d19a66>4</span>;
</span></span></code></pre></div><p>Luckily, C11 features the <code>_Static_assert</code> predicate, as can be seen <a href=https://en.cppreference.com/w/c/language/_Static_assert>here.</a> However, sometimes we are restricted to use older C standards, such as C99, especially for embedded/automotive use. So, is there a way around this conundrum in older C versions?</p><h5 id=no-preprocessor-was-harmed-in-the-writing-of-this-article><strong>No preprocessor was harmed in the writing of this article</strong></h5><p>Actually yes, we can get around this by taking advantage of <code>clang</code>&rsquo;s or <code>gcc</code>&rsquo;s preprocessor/compiler. What we could think of doing, is something kinda like this:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#c678dd>typedef</span> <span style=color:#ef8383>char</span> <span style=color:#c1abea>__something</span>[(<span style=color:#c1abea>expression</span>) <span style=color:#c7bf54>?</span> (<span style=color:#c7bf54>+</span><span style=color:#d19a66>1</span>) <span style=color:#c7bf54>:</span> (<span style=color:#c7bf54>-</span><span style=color:#d19a66>1</span>)];
</span></span></code></pre></div><p>Here, the compiler will evaluate whatever expression that can be statically resolved inside the parentheses and substitute <code>+1</code> if the expression evaluates to <code>true</code> or <code>-1</code> otherwise. Since arrays can&rsquo;t be declared with a negative size, we get a compiler error in case of a negative expression result; or in other words, an assertion failure. Hooray! Let&rsquo;s expand on this; let&rsquo;s have a macro do all of the typing for us:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define STATIC_ASSERT(expr) typedef char __something[(expression) ? (+1) : (-1)];
</span></span></span></code></pre></div><p>The first obvious problem is that we are <code>typedef</code>-ing a new variable type always with the same name (we&rsquo;ll come back to this later&mldr;); also, the <code>__something</code> placeholder that we use might be used already for something else. Ok, so we&rsquo;ll fix those two potential problems using macro concatenation and a little help from <code>__COUNTER__</code>:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define GLUE(a, b) a##b
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define EVAL(expr, name) typedef char GLUE(__assert_test_t_, name)[(expr) ? (+1) : (-1)]
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define STATIC_ASSERT(expr) EVAL(expr, __COUNTER__)
</span></span></span></code></pre></div><p>Now, the <code>__COUNTER__</code> is a special compiler extension macro that gets incremented every time that it&rsquo;s used. So, for example, the preprocessing of:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c678dd>sizeof</span>(<span style=color:#ef8383>int</span>) <span style=color:#c7bf54>==</span> <span style=color:#d19a66>4</span>)
</span></span><span style=display:flex><span><span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c678dd>sizeof</span>(<span style=color:#ef8383>long</span>) <span style=color:#c7bf54>==</span> <span style=color:#d19a66>8</span>)
</span></span></code></pre></div><p>Will result in something like:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#c678dd>typedef</span> <span style=color:#ef8383>char</span> <span style=color:#c1abea>__assert_test_t_0</span>[(<span style=color:#c678dd>sizeof</span>(<span style=color:#ef8383>int</span>) <span style=color:#c7bf54>==</span> <span style=color:#d19a66>4</span>) <span style=color:#c7bf54>?</span> (<span style=color:#c7bf54>+</span><span style=color:#d19a66>1</span>) <span style=color:#c7bf54>:</span> (<span style=color:#c7bf54>-</span><span style=color:#d19a66>1</span>)];
</span></span><span style=display:flex><span><span style=color:#c678dd>typedef</span> <span style=color:#ef8383>char</span> <span style=color:#c1abea>__assert_test_t_1</span>[(<span style=color:#c678dd>sizeof</span>(<span style=color:#ef8383>long</span>) <span style=color:#c7bf54>==</span> <span style=color:#d19a66>8</span>) <span style=color:#c7bf54>?</span> (<span style=color:#c7bf54>+</span><span style=color:#d19a66>1</span>) <span style=color:#c7bf54>:</span> (<span style=color:#c7bf54>-</span><span style=color:#d19a66>1</span>)];
</span></span></code></pre></div><p>These two assertions will <em>correctly fail</em> (give a compiler error) whenever they need to. So that&rsquo;s it, Right?</p><h5 id=misra-comes-in-and-ruins-the-fun><strong>MISRA comes in and ruins the fun</strong></h5><p>Remember when I said that two <code>typedef</code>s can&rsquo;t have the same name? Actually, the compiler doesn&rsquo;t mind; but MISRA-C does. So what is it? It&rsquo;s a set of software development guidelines for the C programming language, aimed to facilitate code safety, security, portability and reliability in the context of embedded systems. It was originally written for the automotive embedded software industry, but nowadays it&rsquo;s also used in other sectors, such as defense, telecommunications, medical devices, etc. If you have ever worked as an embedded C developer in one of those fields you&rsquo;ll know what I&rsquo;m talking about.</p><p>The macro in its original form re-defines a <code>typedef</code> multiple times, violating:</p><ul><li>MISRA-C:2012 rule 5.7: A tag name shall be a unique identifier.</li></ul><p>The second version with <code>__COUNTER__</code> solves this constraint. But, we have a new violation:</p><ul><li>MISRA-C:2012 Rule 2.3: A project should not contain unused type declarations.</li></ul><p>This is because for each <code>STATIC_ASSERT(...)</code> we are defining a new type alias by the name <code>__assert_test_t_n</code>, but we are never actually using it in the code.
Can we circumvent this too? Of course! We just need to actually use the aliased type. Watch this:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define EVAL(expr, name)                                             \
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>    typedef char GLUE(__assert_test_t_, name)[(expr) ? (+1) : (-1)]; \
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>    static GLUE(__assert_test_t_, name) GLUE(__assert_test_var_, name)
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define STATIC_ASSERT(expr) EVAL(expr, __COUNTER__)
</span></span></span></code></pre></div><p>What we are doing is basically declaring a <code>static</code> variable named <code>__assert_test_var_n</code> for each <code>__assert_test_t_n</code> <code>typedef</code> declaration. This assures compliancy with the latter rule.</p><p>However, chances are, that if we check our codebase using MISRA-C rules there is a very high possibility that we also use all of the warning flags available to us (such as <code>-Wall</code> and <code>-Wextra</code>). In this case, we&rsquo;ll get a bunch of warnings telling us about our unused variable declarations; using <code>gcc -Wall -Wextra</code>:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#c1abea>example</span>.<span style=color:#f5a40d>c</span>:<span style=color:#d19a66>6</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>46</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>warning</span>: ‘<span style=color:#c1abea>__assert_test_var_0</span>’ <span style=color:#c1abea>defined</span> <span style=color:#c1abea>but</span> <span style=color:#c1abea>not</span> <span style=color:#c1abea>used</span> [<span style=color:#c7bf54>-</span><span style=color:#c1abea>Wunused</span><span style=color:#c7bf54>-</span><span style=color:#c1abea>variable</span>]
</span></span><span style=display:flex><span>    <span style=color:#d19a66>6</span> <span style=color:#c7bf54>|</span>     <span style=color:#c678dd>static</span> <span style=color:#00b1f7>GLUE</span>(<span style=color:#c1abea>__assert_test_t_</span>, <span style=color:#c1abea>name</span>) <span style=color:#00b1f7>GLUE</span>(<span style=color:#c1abea>__assert_test_var_</span>, <span style=color:#c1abea>name</span>)
</span></span><span style=display:flex><span>      <span style=color:#c7bf54>|</span>                                              <span style=color:#c7bf54>^~~~~~~~~~~~~~~~~~</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>example</span>.<span style=color:#f5a40d>c</span>:<span style=color:#d19a66>3</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>20</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>note</span>: <span style=color:#c1abea>in</span> <span style=color:#c1abea>definition</span> <span style=color:#c1abea>of</span> <span style=color:#c1abea>macro</span> ‘<span style=color:#c1abea>GLUE</span>’
</span></span><span style=display:flex><span>    <span style=color:#d19a66>3</span> <span style=color:#c7bf54>|</span> #<span style=color:#c1abea>define</span> <span style=color:#00b1f7>GLUE</span>(<span style=color:#c1abea>a</span>, <span style=color:#c1abea>b</span>) <span style=color:#c1abea>a</span>##<span style=color:#c1abea>b</span>
</span></span><span style=display:flex><span>      <span style=color:#c7bf54>|</span>                    <span style=color:#c7bf54>^</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>example</span>.<span style=color:#f5a40d>c</span>:<span style=color:#d19a66>7</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>29</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>note</span>: <span style=color:#c1abea>in</span> <span style=color:#c1abea>expansion</span> <span style=color:#c1abea>of</span> <span style=color:#c1abea>macro</span> ‘<span style=color:#c1abea>EVAL</span>’
</span></span><span style=display:flex><span>    <span style=color:#d19a66>7</span> <span style=color:#c7bf54>|</span> #<span style=color:#c1abea>define</span> <span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c1abea>expr</span>) <span style=color:#00b1f7>EVAL</span>(<span style=color:#c1abea>expr</span>, <span style=color:#c1abea>__COUNTER__</span>)
</span></span><span style=display:flex><span>      <span style=color:#c7bf54>|</span>                             <span style=color:#c7bf54>^~~~</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>example</span>.<span style=color:#f5a40d>c</span>:<span style=color:#d19a66>18</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>1</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>note</span>: <span style=color:#c1abea>in</span> <span style=color:#c1abea>expansion</span> <span style=color:#c1abea>of</span> <span style=color:#c1abea>macro</span> ‘<span style=color:#c1abea>STATIC_ASSERT</span>’
</span></span><span style=display:flex><span>   <span style=color:#d19a66>18</span> <span style=color:#c7bf54>|</span> <span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c678dd>sizeof</span>(<span style=color:#ef8383>int</span>) <span style=color:#c7bf54>==</span> <span style=color:#d19a66>4</span>);
</span></span><span style=display:flex><span>      <span style=color:#c7bf54>|</span> <span style=color:#c7bf54>^~~~~~~~~~~~~</span>
</span></span></code></pre></div><p>And using <code>clang -Wall -Wextra</code>:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#c1abea>example</span>.<span style=color:#f5a40d>c</span>:<span style=color:#d19a66>18</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>1</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>warning</span>: <span style=color:#c1abea>unused</span> <span style=color:#c1abea>variable</span> &#39;<span style=color:#c1abea>__assert_test_var_0</span>&#39; [<span style=color:#c7bf54>-</span><span style=color:#c1abea>Wunused</span><span style=color:#c7bf54>-</span><span style=color:#c1abea>variable</span>]
</span></span><span style=display:flex><span><span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c678dd>sizeof</span>(<span style=color:#ef8383>int</span>) <span style=color:#c7bf54>==</span> <span style=color:#d19a66>4</span>);
</span></span><span style=display:flex><span><span style=color:#c7bf54>^</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>example</span>.<span style=color:#f5a40d>c</span>:<span style=color:#d19a66>7</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>29</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>note</span>: <span style=color:#c1abea>expanded</span> <span style=color:#c1abea>from</span> <span style=color:#c1abea>macro</span> &#39;<span style=color:#c1abea>STATIC_ASSERT</span>&#39;
</span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define STATIC_ASSERT(expr) EVAL(expr, __COUNTER__)
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span>                            <span style=color:#c7bf54>^</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>example</span>.<span style=color:#f5a40d>c</span>:<span style=color:#d19a66>6</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>41</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>note</span>: <span style=color:#c1abea>expanded</span> <span style=color:#c1abea>from</span> <span style=color:#c1abea>macro</span> &#39;<span style=color:#c1abea>EVAL</span>&#39;
</span></span><span style=display:flex><span>    <span style=color:#c678dd>static</span> <span style=color:#00b1f7>GLUE</span>(<span style=color:#c1abea>__assert_test_t_</span>, <span style=color:#c1abea>name</span>) <span style=color:#00b1f7>GLUE</span>(<span style=color:#c1abea>__assert_test_var_</span>, <span style=color:#c1abea>name</span>)
</span></span><span style=display:flex><span>                                        <span style=color:#c7bf54>^</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>example</span>.<span style=color:#f5a40d>c</span>:<span style=color:#d19a66>3</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>20</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>note</span>: <span style=color:#c1abea>expanded</span> <span style=color:#c1abea>from</span> <span style=color:#c1abea>macro</span> &#39;<span style=color:#c1abea>GLUE</span>&#39;
</span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define GLUE(a, b) a##b
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span>                   <span style=color:#c7bf54>^</span>
</span></span><span style=display:flex><span><span style=color:#c7bf54>&lt;</span><span style=color:#c1abea>scratch</span> <span style=color:#c1abea>space</span><span style=color:#c7bf54>&gt;:</span><span style=color:#d19a66>49</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>1</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>note</span>: <span style=color:#c1abea>expanded</span> <span style=color:#c1abea>from</span> <span style=color:#c1abea>here</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>__assert_test_var_0</span>
</span></span><span style=display:flex><span><span style=color:#c7bf54>^</span>
</span></span><span style=display:flex><span><span style=color:#d19a66>1</span> <span style=color:#c1abea>warning</span> <span style=color:#c1abea>generated</span>.
</span></span></code></pre></div><p>This can be hastily fixed though, using the <code>__attribute__((unused))</code> compiler extension in our macro. By adding this:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define EVAL(expr, name)                                             \
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>    typedef char GLUE(__assert_test_t_, name)[(expr) ? (+1) : (-1)]; \
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>    static GLUE(__assert_test_t_, name) GLUE(__assert_test_var_, name) __attribute__((unused))
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define STATIC_ASSERT(expr) EVAL(expr, __COUNTER__)
</span></span></span></code></pre></div><p>We get zero warnings with both <code>gcc -Wall -Wextra</code> and <code>clang -Wall -Wextra</code>. While using the latter, if we compile with <code>-g</code> to include the debug symbols as well, we can also see using <code>objdump</code> that the assertion&rsquo;s type alias symbols and static variables definitions don&rsquo;t even get included in the final binary object, and thus not even using an extra bit of space (tested with <code>gcc 11.4.0</code> and <code>clang 14.0.0</code>).</p><h5 id=about-that-misra><strong>About that MISRA&mldr;</strong></h5><p>Actually, you might have noticed that this static assertion implementation clearly violates one of MISRA&rsquo;s rules:</p><ul><li>MISRA-C:2012 rule 20.10: The # and ## preprocessor operators should not be used.</li></ul><p><em>However</em>, I would like to point out that this rule is only <em>advisory</em> and its analysis is <em>decidable</em>. Moreover, the rationale behind this rule argues that:</p><blockquote><h5 id=rule-2010-rationale>Rule 20.10 Rationale:</h5><blockquote><p><em>The order of evaluation associated with multiple #, multiple ## or a mix of # and ## preprocessor operators is unspecified. In some cases it is therefore not possible to predict the result of macro expansion.</em></p><p><em>The use of the ## operator can result in code that is obscure.</em></p></blockquote></blockquote><p>In our case though, the evaluation order is clearly well defined and leaves no room for interpretation; so I think that it&rsquo;s a valid exception to the rule, and that the benefits of having a static assertion predicate in C99 is totally worth it.</p><h3 id=conclusions><strong>Conclusions</strong></h3><p>Here is the macro in its final form:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define GLUE(a, b) a##b
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define EVAL(expr, name)                                             \
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>    typedef char GLUE(__assert_test_t_, name)[(expr) ? (+1) : (-1)]; \
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>    static GLUE(__assert_test_t_, name) GLUE(__assert_test_var_, name) __attribute__((unused))
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define STATIC_ASSERT(expr) EVAL(expr, __COUNTER__)
</span></span></span></code></pre></div><p>With this predicate we would get a compilation error whenever the expression fails; the problems described above would be managed as such:</p><ul><li>Ex. 0 (platform specific type checks):<div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>// Are the platform&#39;s types of the required size?
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span><span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c678dd>sizeof</span>(<span style=color:#ef8383>int</span>) <span style=color:#c7bf54>==</span> <span style=color:#d19a66>4</span>);
</span></span><span style=display:flex><span><span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c678dd>sizeof</span>(<span style=color:#ef8383>long</span> <span style=color:#ef8383>long</span>) <span style=color:#c7bf54>==</span> <span style=color:#d19a66>8</span>);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>// Is the &#34;char&#34; type signed?
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span><span style=color:#8a93a5;font-style:italic>#include</span> <span style=color:#8a93a5;font-style:italic>&lt;limits.h&gt;</span><span style=color:#8a93a5;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span><span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c1abea>CHAR_MIN</span> <span style=color:#c7bf54>&lt;</span> <span style=color:#d19a66>0</span>);
</span></span></code></pre></div></li><li>Ex. 1:<div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>// Did you forget to pack your struct?
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span><span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c678dd>sizeof</span>(<span style=color:#c1abea>PackedOrNot_t</span>) <span style=color:#c7bf54>==</span> <span style=color:#d19a66>3</span>);
</span></span></code></pre></div></li><li>Ex. 2:<div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>// Did you forget some extra padding bytes in your struct definition?
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span><span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c678dd>sizeof</span>(<span style=color:#c1abea>EightBytesMultiple_t</span>) <span style=color:#c7bf54>%</span> <span style=color:#d19a66>8</span> <span style=color:#c7bf54>==</span> <span style=color:#d19a66>0</span>);
</span></span></code></pre></div></li><li>Ex. 3:<div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>// Does integer division with negative values correctly round towards zero?
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span><span style=color:#00b1f7>STATIC_ASSERT</span>(<span style=color:#c7bf54>-</span><span style=color:#d19a66>10</span> <span style=color:#c7bf54>/</span> <span style=color:#d19a66>4</span> <span style=color:#c7bf54>==</span> <span style=color:#c7bf54>-</span><span style=color:#d19a66>2</span>);
</span></span></code></pre></div></li></ul><h3 id=something-extra><strong>Something extra</strong></h3><p>I just wanted to add and extra goodie: let&rsquo;s say that you have a very long and nested <code>struct</code> definition in your code:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#c678dd>typedef</span> <span style=color:#c678dd>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ef8383>int</span> <span style=color:#c1abea>a</span>;
</span></span><span style=display:flex><span>    <span style=color:#ef8383>short</span> <span style=color:#c1abea>b</span>;
</span></span><span style=display:flex><span>    <span style=color:#ef8383>unsigned</span> <span style=color:#ef8383>long</span> <span style=color:#c1abea>c</span>[<span style=color:#d19a66>10</span>];
</span></span><span style=display:flex><span>    <span style=color:#c1abea>SomeOtherStruct_t</span> <span style=color:#c1abea>d</span>;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} <span style=color:#c1abea>VeryLongStruct_t</span>;
</span></span></code></pre></div><p>What if you needed to get its <code>sizeof</code> without doing all of the calculation by hand, or going in debug mode? Well this macro comes in handy:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>#define SIZEOF_WARN(type) char (*__var)[sizeof(type)] = 1;
</span></span></span></code></pre></div><p>When compiled, this macro will give a compiler warning with the correct <code>sizeof</code> in the warning&rsquo;s output. Example use:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#00b1f7>SIZEOF_WARN</span>(<span style=color:#c1abea>VeryLongStruct_t</span>)
</span></span></code></pre></div><p>Compile with the usual <code>-Wall -Wextra</code> flags and voila:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#c1abea>example</span>.<span style=color:#f5a40d>c</span>:<span style=color:#d19a66>9</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>57</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>warning</span>: <span style=color:#c1abea>initialization</span> <span style=color:#c1abea>of</span> ‘<span style=color:#ef8383>char</span> (<span style=color:#c7bf54>*</span>)[<span style=color:#d19a66>246</span>]’ <span style=color:#c1abea>from</span> ‘<span style=color:#ef8383>int</span>’ <span style=color:#c1abea>makes</span> <span style=color:#c1abea>pointer</span> <span style=color:#c1abea>from</span> <span style=color:#c1abea>integer</span> <span style=color:#c1abea>without</span> <span style=color:#c1abea>a</span> <span style=color:#c1abea>cast</span> [<span style=color:#c7bf54>-</span><span style=color:#c1abea>Wint</span><span style=color:#c7bf54>-</span><span style=color:#c1abea>conversion</span>]
</span></span><span style=display:flex><span>    <span style=color:#d19a66>9</span> <span style=color:#c7bf54>|</span> #<span style=color:#c1abea>define</span> <span style=color:#00b1f7>SIZEOF_WARN</span>(<span style=color:#c1abea>type</span>) <span style=color:#ef8383>char</span> (<span style=color:#c7bf54>*</span><span style=color:#c1abea>__var</span>)[<span style=color:#c678dd>sizeof</span>(<span style=color:#c1abea>type</span>)] <span style=color:#c7bf54>=</span> <span style=color:#d19a66>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#c7bf54>|</span>                                                         <span style=color:#c7bf54>^</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>example</span>.<span style=color:#f5a40d>c</span>:<span style=color:#d19a66>20</span><span style=color:#c7bf54>:</span><span style=color:#d19a66>1</span><span style=color:#c7bf54>:</span> <span style=color:#f5a40d>note</span>: <span style=color:#c1abea>in</span> <span style=color:#c1abea>expansion</span> <span style=color:#c1abea>of</span> <span style=color:#c1abea>macro</span> ‘<span style=color:#c1abea>SIZEOF_WARN</span>’
</span></span><span style=display:flex><span>   <span style=color:#d19a66>20</span> <span style=color:#c7bf54>|</span> <span style=color:#00b1f7>SIZEOF_WARN</span>(<span style=color:#c1abea>VeryLongStruct_t</span>)
</span></span><span style=display:flex><span>      <span style=color:#c7bf54>|</span> <span style=color:#c7bf54>^~~~~~~~~~~</span>
</span></span></code></pre></div><p>Your <code>VeryLongStruct_t</code> has a <code>sizeof</code> value of <strong>246</strong>.</p></div></div><div class="flex flex-row justify-around my-2"><h3 class="mb-1 mt-1 text-left mr-4"><i class="text-gray-300 dark:text-gray-600 fas fa-chevron-circle-left"></i></h3><h3 class="mb-1 mt-1 text-left ml-4"><i class="text-gray-300 dark:text-gray-600 fas fa-chevron-circle-right"></i></h3></div></main><footer class="text-sm text-center border-t border-gray-300 dark:border-gray-700 py-6"><p class=markdownify>Made with ❤️ and <a href=https://gohugo.io/>Hugo</a></p></footer></body></html>